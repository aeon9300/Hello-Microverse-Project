"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const url_1 = require("url");
const parse5 = require("parse5");
const htmlparser2Adapter = require("parse5-htmlparser2-tree-adapter");
const cssSelect = require("css-select");
const find_original_element_1 = require("./find-original-element");
const CACHED_CSS_SELECTORS = new Map();
class HTMLElement {
    constructor(element, ownerDocument) {
        this._element = element instanceof HTMLElement ? element._element : element;
        this.ownerDocument = ownerDocument;
    }
    get attributes() {
        const x = this._element.attribs;
        return Object.entries(x).map(([name, value]) => {
            return {
                name,
                value
            };
        });
    }
    get children() {
        const result = [];
        for (const child of this._element.children) {
            if (child.type === 'tag' || child.type === 'script' || child.type === 'style') {
                result.push(new HTMLElement(child, this.ownerDocument));
            }
        }
        return result;
    }
    get parentElement() {
        const parent = this._element.parent;
        if (!parent || (parent.type !== 'tag' && parent.type !== 'script' && parent.type !== 'style')) {
            return null;
        }
        return new HTMLElement(parent, this.ownerDocument);
    }
    get nodeName() {
        return this._element.name;
    }
    getAttribute(attribute) {
        const attrib = this._element.attribs[attribute];
        const value = typeof attrib !== 'undefined' ? attrib : null;
        return value;
    }
    isAttributeAnExpression(attribute) {
        const value = this.getAttribute(attribute);
        return value ? value.includes('{') : false;
    }
    _getOriginalLocation() {
        const location = this._element.sourceCodeLocation;
        if (location) {
            return location;
        }
        if (this.ownerDocument.originalDocument) {
            const match = find_original_element_1.findOriginalElement(this.ownerDocument.originalDocument, this);
            if (match) {
                return match._element.sourceCodeLocation || null;
            }
        }
        return null;
    }
    getLocation() {
        const location = this._getOriginalLocation();
        return {
            column: location ? location.startCol : -1,
            elementId: this._element.id,
            line: location ? location.startLine - 1 : -1
        };
    }
    getContentLocation(offset) {
        const location = this._getOriginalLocation();
        if (!location) {
            return null;
        }
        const startTag = location.startTag;
        const column = startTag.endCol - 1;
        const line = startTag.endLine - 1;
        if (offset.line === 0) {
            return {
                column: column + offset.column,
                line
            };
        }
        return {
            column: offset.column,
            line: line + offset.line
        };
    }
    isSame(element) {
        return this._element === element._element;
    }
    get innerHTML() {
        return parse5.serialize(this._element, { treeAdapter: htmlparser2Adapter });
    }
    get outerHTML() {
        const fragment = htmlparser2Adapter.createDocumentFragment();
        const { parent, next, prev } = this._element;
        htmlparser2Adapter.appendChild(fragment, this._element);
        const result = parse5.serialize(fragment, { treeAdapter: htmlparser2Adapter });
        this._element.parent = parent;
        this._element.next = next;
        this._element.prev = prev;
        if (next) {
            next.prev = this._element;
        }
        if (prev) {
            prev.next = this._element;
        }
        return result;
    }
    resolveUrl(url) {
        return this.ownerDocument.resolveUrl(url);
    }
}
exports.HTMLElement = HTMLElement;
class HTMLDocument {
    constructor(document, finalHref, originalDocument) {
        this._pageHTML = '';
        this._document = document;
        this._documentElement = this.findDocumentElement();
        this.originalDocument = originalDocument;
        this._pageHTML = parse5.serialize(document, { treeAdapter: htmlparser2Adapter });
        this._base = this.getBaseUrl(finalHref);
    }
    findDocumentElement() {
        return this._document.children.find((node) => {
            return node.type === 'tag' && node.name === 'html';
        });
    }
    getBaseUrl(finalHref) {
        const baseElement = this.querySelectorAll('base[href]')[0];
        const baseHref = baseElement ? baseElement.getAttribute('href') : null;
        if (!baseHref) {
            return new url_1.URL(finalHref).href;
        }
        return new url_1.URL(baseHref, finalHref).href;
    }
    get documentElement() {
        return new HTMLElement(this._documentElement, this);
    }
    get base() {
        return this._base;
    }
    get isFragment() {
        return !this.originalDocument && !this._documentElement.sourceCodeLocation;
    }
    pageHTML() {
        return this._pageHTML;
    }
    querySelectorAll(selector) {
        if (!CACHED_CSS_SELECTORS.has(selector)) {
            CACHED_CSS_SELECTORS.set(selector, cssSelect.compile(selector));
        }
        const matches = cssSelect(CACHED_CSS_SELECTORS.get(selector), this._document.children);
        const result = matches.map((element) => {
            return new HTMLElement(element, this);
        });
        return result;
    }
    resolveUrl(url) {
        return new url_1.URL(url, this._base).href;
    }
}
exports.HTMLDocument = HTMLDocument;
