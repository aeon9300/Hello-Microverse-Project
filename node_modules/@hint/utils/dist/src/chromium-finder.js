"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const is_file_1 = require("./fs/is-file");
const is_directory_1 = require("./fs/is-directory");
const environment_1 = require("./misc/environment");
const get_platform_1 = require("./misc/get-platform");
const child_process_1 = require("child_process");
const newLineRegex = /\r?\n/;
var Browser;
(function (Browser) {
    Browser["Chrome"] = "Chrome";
    Browser["Chromium"] = "Chromium";
    Browser["Edge"] = "Edge";
})(Browser = exports.Browser || (exports.Browser = {}));
const ERRORS = {
    InvalidPath: 'The provided path is not accessible',
    NoInstallationFound: 'No installation found',
    NotSupportedBrowser: 'The provided browser is not supported in this platform',
    UnsupportedPlatform: 'Unsupported platform'
};
const browserVariables = new Map([
    ['darwin', new Map([
            [
                Browser.Chrome, [
                    '/Contents/MacOS/Google Chrome Canary',
                    '/Contents/MacOS/Google Chrome'
                ]
            ],
            [
                Browser.Chromium, [
                    '/Contents/MacOS/Chromium'
                ]
            ],
            [
                Browser.Edge, [
                    '/Contents/MacOS/Microsoft Edge Canary'
                ]
            ]
        ])],
    ['linux', new Map([
            [
                Browser.Chrome, [
                    '(google-chrome|chrome)',
                    'google-chrome-stable',
                    'google-chrome'
                ]
            ],
            [
                Browser.Chromium, [
                    '(chromium)',
                    'chromium-browser',
                    'chromium'
                ]
            ]
        ])],
    ['win32', new Map([
            [
                Browser.Chrome, [
                    `${path.sep}Google${path.sep}Chrome SxS${path.sep}Application${path.sep}chrome.exe`,
                    `${path.sep}Google${path.sep}Chrome${path.sep}Application${path.sep}chrome.exe`
                ]
            ],
            [
                Browser.Chromium, [
                    `${path.sep}Chromium${path.sep}Application${path.sep}chromium.exe`
                ]
            ],
            [
                Browser.Edge, [
                    `${path.sep}Microsoft${path.sep}Edge SxS${path.sep}Application${path.sep}msedge.exe`,
                    `${path.sep}Microsoft${path.sep}Edge${path.sep}Application${path.sep}msedge.exe`,
                    `${path.sep}Microsoft${path.sep}Edge Dev SxS${path.sep}Application${path.sep}msedge.exe`,
                    `${path.sep}Microsoft${path.sep}Edge Dev${path.sep}Application${path.sep}msedge.exe`
                ]
            ]
        ])]
]);
const darwin = (browser) => {
    const platformBrowserInfo = browserVariables.get('darwin');
    const suffixes = platformBrowserInfo.get(browser);
    if (!suffixes) {
        throw new Error(ERRORS.NotSupportedBrowser);
    }
    const LSREGISTER = '/System/Library/Frameworks/CoreServices.framework' +
        '/Versions/A/Frameworks/LaunchServices.framework' +
        '/Versions/A/Support/lsregister';
    const lines = child_process_1.execSync(`${LSREGISTER} -dump` +
        ` | grep -i '\.app$'` +
        ` | awk '{$1=""; print $0}'`)
        .toString()
        .split(newLineRegex);
    for (const suffix of suffixes) {
        for (const inst of lines) {
            const execPath = path.join(inst.trim(), suffix);
            if (is_file_1.isFile(execPath)) {
                return execPath;
            }
        }
    }
    return '';
};
const findChromeExecutable = (folder, regExes) => {
    const argumentsRegex = /(^[^ ]+).*/;
    for (const browserRegex of regExes) {
        const chromeExecRegex = `^Exec=/.*/${browserRegex}-.*`;
        if (is_directory_1.isDirectory(folder)) {
            let execPaths;
            try {
                execPaths = child_process_1.execSync(`grep -ER "${chromeExecRegex}" ${folder} | awk -F '=' '{print $2}'`);
            }
            catch (e) {
                execPaths = child_process_1.execSync(`grep -Er "${chromeExecRegex}" ${folder} | awk -F '=' '{print $2}'`);
            }
            execPaths = execPaths.toString()
                .split(newLineRegex)
                .map((execPath) => {
                return execPath.replace(argumentsRegex, '$1');
            });
            for (const execPath of execPaths) {
                if (is_file_1.isFile(execPath)) {
                    return execPath;
                }
            }
        }
    }
    return '';
};
const linux = (browser) => {
    const desktopInstallationFolders = [
        path.join(require('os').homedir(), '.local/share/applications/'),
        '/usr/share/applications/'
    ];
    const browserPartsInfo = browserVariables.get('linux');
    const executables = browserPartsInfo.get(browser);
    if (!executables) {
        throw new Error(ERRORS.NotSupportedBrowser);
    }
    for (const folder of desktopInstallationFolders) {
        const executable = findChromeExecutable(folder, executables);
        if (executable) {
            return executable;
        }
    }
    for (const executable of executables) {
        try {
            const chromePath = child_process_1.execFileSync('which', [executable], { stdio: 'pipe' }).toString()
                .split(newLineRegex)[0];
            if (chromePath && is_file_1.isFile(chromePath)) {
                return chromePath;
            }
        }
        catch (e) {
        }
    }
    return '';
};
const win32 = (browser) => {
    const info = browserVariables.get('win32');
    const suffixes = info.get(browser);
    if (!suffixes) {
        throw new Error(ERRORS.NotSupportedBrowser);
    }
    const prefixes = [
        environment_1.getVariable('LOCALAPPDATA'),
        environment_1.getVariable('PROGRAMFILES'),
        environment_1.getVariable('PROGRAMFILES(X86)')
    ].filter(Boolean);
    for (const suffix of suffixes) {
        for (const prefix of prefixes) {
            const browserPath = path.join(prefix, suffix);
            if (is_file_1.isFile(browserPath)) {
                return browserPath;
            }
        }
    }
    return '';
};
const finders = new Map([
    ['darwin', darwin],
    ['linux', linux],
    ['win32', win32],
    ['wsl', linux]
]);
const findBrowserPath = (browser) => {
    const platform = get_platform_1.getPlatform();
    const finder = finders.get(platform);
    if (!finder) {
        throw new Error(ERRORS.UnsupportedPlatform);
    }
    return finder(browser);
};
const resolveChromiumPath = () => {
    const chromiumPaths = [
        environment_1.getVariable('WEBHINT_CHROMIUM_PATH'),
        environment_1.getVariable('CHROME_PATH')
    ];
    while (chromiumPaths.length > 0) {
        const browserPath = chromiumPaths.shift();
        if (is_file_1.isFile(browserPath)) {
            return browserPath;
        }
    }
    return '';
};
exports.getInstallationPath = (options) => {
    if (options && options.browserPath) {
        if (is_file_1.isFile(options.browserPath)) {
            return options.browserPath;
        }
        throw new Error(ERRORS.InvalidPath);
    }
    const resolvedChromiumPath = resolveChromiumPath();
    if (resolvedChromiumPath) {
        return resolvedChromiumPath;
    }
    if (options && options.browser) {
        const browserPath = findBrowserPath(options.browser);
        if (browserPath) {
            return browserPath;
        }
        throw new Error(ERRORS.NoInstallationFound);
    }
    const browsers = [Browser.Chrome, Browser.Chromium, Browser.Edge];
    let browserFound = '';
    while (browsers.length > 0 && !browserFound) {
        const br = browsers.shift();
        try {
            browserFound = findBrowserPath(br);
        }
        catch (e) {
        }
    }
    if (!browserFound) {
        throw new Error(ERRORS.NoInstallationFound);
    }
    return browserFound;
};
