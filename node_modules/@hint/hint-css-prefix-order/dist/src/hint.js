"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const postcss_1 = require("postcss");
const debug_1 = require("@hint/utils/dist/src/debug");
const get_css_code_snippet_1 = require("@hint/utils/dist/src/report/get-css-code-snippet");
const meta_1 = require("./meta");
const i18n_import_1 = require("./i18n.import");
const report_1 = require("@hint/utils/dist/src/report");
const debug = debug_1.debug(__filename);
const validatePair = (pair) => {
    if (!pair.lastPrefixed || !pair.unprefixed) {
        return false;
    }
    const prefixedLocation = report_1.getCSSLocationFromNode(pair.lastPrefixed) || { column: 0, line: 0 };
    const unprefixedLocation = report_1.getCSSLocationFromNode(pair.unprefixed) || { column: 0, line: 0 };
    if (prefixedLocation.line < unprefixedLocation.line) {
        return false;
    }
    if (prefixedLocation.line > unprefixedLocation.line) {
        return true;
    }
    return prefixedLocation.column > unprefixedLocation.column;
};
const validateRule = (rule) => {
    const map = new Map();
    rule.each((decl) => {
        if (!('prop' in decl)) {
            return;
        }
        const name = decl.prop;
        const baseName = postcss_1.vendor.unprefixed(name);
        const value = decl.value;
        const baseValue = postcss_1.vendor.unprefixed(value);
        if (!map.has(baseName)) {
            map.set(baseName, {});
        }
        const pair = map.get(baseName);
        if (name === baseName && value === baseValue) {
            pair.unprefixed = decl;
        }
        else {
            pair.lastPrefixed = decl;
        }
    });
    return [...map.values()].filter(validatePair);
};
class CssPrefixOrderHint {
    constructor(context) {
        const formatMessage = (invalidPair) => {
            let name = invalidPair.unprefixed.prop;
            let prefixedName = invalidPair.lastPrefixed.prop;
            if (name === prefixedName) {
                name = `${invalidPair.unprefixed}`;
                prefixedName = `${invalidPair.lastPrefixed}`;
            }
            return i18n_import_1.getMessage('shouldBeListed', context.language, [name, prefixedName]);
        };
        context.on('parse::end::css', ({ ast, element, resource }) => {
            debug('Validating hint css-prefix-order');
            ast.walkRules((rule) => {
                for (const invalidPair of validateRule(rule)) {
                    const message = formatMessage(invalidPair);
                    const isValue = invalidPair.lastPrefixed.prop === invalidPair.unprefixed.prop;
                    const location = report_1.getCSSLocationFromNode(invalidPair.unprefixed, { isValue });
                    const codeSnippet = get_css_code_snippet_1.getCSSCodeSnippet(invalidPair.unprefixed);
                    context.report(resource, message, { codeLanguage: 'css', codeSnippet, element, location });
                }
            });
        });
    }
}
exports.default = CssPrefixOrderHint;
CssPrefixOrderHint.meta = meta_1.default;
