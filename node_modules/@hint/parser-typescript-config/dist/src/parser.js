"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
const path = require("path");
const util_1 = require("util");
const lodash_1 = require("lodash");
const utils_1 = require("@hint/utils");
const hint_1 = require("hint");
const { jsonParser: { parseJSON }, schemaValidator: { validate } } = hint_1.utils;
const { loadJSONFile, writeFileAsync } = utils_1.fs;
const { requestAsync } = utils_1.network;
const debug = utils_1.debug(__filename);
const oneDay = 3600000 * 24;
class TypeScriptConfigParser extends hint_1.Parser {
    constructor(engine) {
        super(engine, 'typescript-config');
        this.schemaUpdated = false;
        this.schemaPath = path.join(__dirname, 'schema.json');
        this.schema = loadJSONFile(this.schemaPath);
        engine.on('fetch::end::*', this.parseTypeScript.bind(this));
    }
    async validateSchema(config, resource, result) {
        const validationResult = validate(this.schema, config, result.getLocation);
        const valid = validationResult.valid;
        if (!valid) {
            await this.engine.emitAsync(`parse::error::typescript-config::schema`, {
                error: new Error('Invalid TypeScript configuration'),
                errors: validationResult.errors,
                groupedErrors: validationResult.groupedErrors,
                prettifiedErrors: validationResult.prettifiedErrors,
                resource
            });
        }
        return validationResult;
    }
    compilerOptionsExists(schema) {
        return schema.definitions &&
            schema.definitions.compilerOptionsDefinition &&
            schema.definitions.compilerOptionsDefinition.properties &&
            schema.definitions.compilerOptionsDefinition.properties.compilerOptions;
    }
    typeAcquisitionExists(schema) {
        return schema.definitions &&
            schema.definitions.typeAcquisitionDefinition &&
            schema.definitions.typeAcquisitionDefinition.properties &&
            schema.definitions.typeAcquisitionDefinition.properties.typeAcquisition;
    }
    async getFileStat(file) {
        let stats = null;
        try {
            stats = await util_1.promisify(fs.stat)(file);
        }
        catch (e) {
            debug('Error getting the schema file stats');
            debug(e);
        }
        return stats;
    }
    async downloadSchema() {
        let schema = null;
        try {
            schema = JSON.parse(await requestAsync('http://json.schemastore.org/tsconfig'));
        }
        catch (e) {
            debug('Error downloading the schema file');
            debug(e);
        }
        return schema;
    }
    async updateSchema() {
        const now = Date.now();
        const schemaStat = await this.getFileStat(this.schemaPath);
        const modified = schemaStat ? new Date(schemaStat.mtime).getTime() : Date.now();
        if (!schemaStat || (now - modified > oneDay)) {
            debug('TypeScript Schema is older than 24h.');
            debug('Updating TypeScript Schema');
            const schema = await this.downloadSchema();
            if (this.compilerOptionsExists(schema)) {
                schema.definitions.compilerOptionsDefinition.properties.compilerOptions.additionalProperties = false;
            }
            if (this.typeAcquisitionExists(schema)) {
                schema.definitions.typeAcquisitionDefinition.properties.typeAcquisition.additionalProperties = false;
            }
            this.schema = schema;
            await writeFileAsync(this.schemaPath, JSON.stringify(schema, null, 2));
        }
        this.schemaUpdated = true;
    }
    async parseTypeScript(fetchEnd) {
        const resource = fetchEnd.resource;
        const fileName = path.basename(resource);
        if (!fileName.match(/^tsconfig\.([^.]*\.)?json$/gi) || fileName === 'tsconfig.schema.json') {
            return;
        }
        await this.engine.emitAsync(`parse::start::typescript-config`, { resource });
        let result;
        try {
            if (!this.schemaUpdated) {
                await this.updateSchema();
            }
            result = parseJSON(fetchEnd.response.body.content);
            const originalConfig = lodash_1.cloneDeep(result.data);
            const config = await this.finalConfig(result.data, resource);
            if (config instanceof Error) {
                await this.engine.emitAsync(`parse::error::typescript-config::extends`, {
                    error: config,
                    getLocation: result.getLocation,
                    resource: config.resource
                });
                return;
            }
            if (!config) {
                return;
            }
            const validationResult = await this.validateSchema(config, resource, result);
            if (!validationResult.valid) {
                return;
            }
            await this.engine.emitAsync(`parse::end::typescript-config`, {
                config: validationResult.data,
                getLocation: result.getLocation,
                mergedConfig: config,
                originalConfig,
                resource
            });
        }
        catch (err) {
            await this.engine.emitAsync(`parse::error::typescript-config::json`, {
                error: err,
                resource
            });
        }
    }
}
exports.default = TypeScriptConfigParser;
