/// <reference types="node" />
import { URL } from 'url';
import { HTMLElement } from '@hint/utils/dist/src/dom/html';
import { Engine } from './engine';
import { Events, HintMetadata, NetworkData, StringKeyOf } from './types';
import { ProblemLocation, Severity } from '@hint/utils/dist/src/types/problems';
export declare type CodeLanguage = 'css' | 'html' | 'http' | 'javascript';
export declare type ReportOptions = {
    codeSnippet?: string;
    content?: string;
    element?: HTMLElement | null;
    location?: ProblemLocation | null;
    severity?: Severity;
    codeLanguage?: CodeLanguage;
};
export declare class HintContext<E extends Events = Events> {
    private id;
    private options;
    private meta;
    private severity;
    private engine;
    private ignoredUrls;
    constructor(hintId: string, engine: Engine<E>, severity: Severity, options: any, meta: HintMetadata, ignoredUrls: RegExp[]);
    readonly engineKey: object;
    readonly pageDOM: import("@hint/utils/dist/src/dom/html").HTMLDocument | undefined;
    readonly pageContent: string | undefined;
    readonly pageHeaders: import("@hint/utils").HttpHeaders | undefined;
    readonly targetedBrowsers: string[];
    readonly hintOptions: any;
    evaluate(source: string): Promise<any>;
    fetchContent(target: string | URL, headers?: object): Promise<NetworkData>;
    querySelectorAll(selector: string): HTMLElement[];
    findProblemLocation(element: HTMLElement, offset: ProblemLocation | null): ProblemLocation | null;
    report(resource: string, message: string, options?: ReportOptions): void;
    on<K extends StringKeyOf<E>>(event: K, listener: (data: E[K], event: string) => void): void;
    isUrlIgnored(resource: string): boolean;
    readonly language: string;
}
//# sourceMappingURL=hint-context.d.ts.map