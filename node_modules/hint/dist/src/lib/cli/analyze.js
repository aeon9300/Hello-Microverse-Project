"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const boxen = require("boxen");
const chalk = require("chalk");
const isCI = require("is-ci");
const ora = require("ora");
const osLocale = require("os-locale");
const utils_1 = require("@hint/utils");
const problems_1 = require("@hint/utils/dist/src/types/problems");
const load_hint_package_1 = require("../utils/packages/load-hint-package");
const __1 = require("../");
const error_status_1 = require("../enums/error-status");
const { getAsUris } = utils_1.network;
const { askQuestion, mergeEnvWithOptions } = utils_1.misc;
const { installPackages } = utils_1.npm;
const { cwd } = utils_1.fs;
const debug = utils_1.debug(__filename);
const alreadyRunKey = 'run';
const spinner = ora({ spinner: 'line' });
const printFrame = (message) => {
    utils_1.logger.log(boxen(message, {
        align: 'center',
        margin: 1,
        padding: 1
    }));
};
const showTelemetryMessage = () => {
    const message = `Help us improve webhint
by sending limited usage information
(no personal information or URLs will be sent).

To know more about what information will be sent please
visit ${chalk.default.green('https://webhint.io/docs/user-guide/telemetry/summary/')}`;
    printFrame(message);
};
const showCITelemetryMessage = () => {
    const message = `Help us improve webhint
by sending limited usage information
(no personal information or URLs will be sent).

To know more about what information will be sent please
visit ${chalk.default.green('https://webhint.io/docs/user-guide/telemetry/summary/')}

Please configure it using
the environment variable HINT_TRACKING to 'on' or 'off'
or set the flag --tracking=on|off`;
    printFrame(message);
};
const getHintsForTelemetry = (hints) => {
    if (!hints) {
        return null;
    }
    const normalizedHints = utils_1.normalizeHints(hints);
    const result = {};
    for (const [hintId, severity] of Object.entries(normalizedHints)) {
        result[hintId] = typeof severity === 'string' ? severity : severity[0];
    }
    return result;
};
const pruneUserConfig = (userConfig) => {
    return {
        browserslist: userConfig.browserslist,
        connector: userConfig.connector ? userConfig.connector.name || userConfig.connector : undefined,
        extends: userConfig.extends,
        formatters: userConfig.formatters,
        hints: getHintsForTelemetry(utils_1.getHintsFromConfiguration(userConfig)),
        hintsTimeout: userConfig.hintsTimeout,
        language: userConfig.language,
        parsers: userConfig.parsers
    };
};
const askForTelemetryConfirmation = async () => {
    showTelemetryMessage();
    const message = `Do you want to opt-in?`;
    debug(`Prompting telemetry permission.`);
    const telemetryEnabled = await askQuestion(message);
    if (telemetryEnabled) {
        utils_1.appInsights.enable();
    }
    else {
        utils_1.appInsights.disable();
    }
    return telemetryEnabled;
};
const sendTelemetryIfEnabled = async (userConfig) => {
    const telemetryConfigured = utils_1.appInsights.isConfigured();
    let telemetryEnabled = utils_1.appInsights.isEnabled();
    const alreadyRun = utils_1.configStore.get(alreadyRunKey);
    if (!alreadyRun) {
        utils_1.configStore.set(alreadyRunKey, true);
    }
    if (!telemetryConfigured) {
        if (isCI) {
            showCITelemetryMessage();
            telemetryEnabled = false;
        }
        else if (alreadyRun) {
            telemetryEnabled = await askForTelemetryConfirmation();
            if (telemetryEnabled) {
                utils_1.appInsights.trackEvent('cli-telemetry');
            }
        }
    }
    if (!telemetryEnabled) {
        return;
    }
    utils_1.appInsights.trackEvent('cli-analyze', Object.assign({ ci: isCI, previouslyRun: alreadyRun }, pruneUserConfig(userConfig)));
};
const showDefaultMessage = () => {
    const defaultMessage = `${chalk.default.yellow(`Couldn't find any valid configuration`)}

Running hint with the default configuration.

Learn more about how to create your own configuration at:

${chalk.default.green('https://webhint.io/docs/user-guide/')}`;
    printFrame(defaultMessage);
};
const areFiles = (targets) => {
    return targets.every((target) => {
        return target.protocol === 'file:';
    });
};
const anyFile = (targets) => {
    return targets.some((target) => {
        return target.protocol === 'file:';
    });
};
const getDefaultConfiguration = (targets) => {
    showDefaultMessage();
    const targetsAreFiles = areFiles(targets);
    if (!targetsAreFiles && anyFile(targets)) {
        throw new Error('You cannot mix file system with urls in the analysis');
    }
    const ext = targetsAreFiles ? 'development' : 'web-recommended';
    const config = { extends: [ext] };
    if (isCI) {
        config.formatters = ['html', 'stylish'];
    }
    return config;
};
const askUserToUseDefaultConfiguration = async (targets) => {
    const question = `A valid configuration file can't be found. Do you want to use the default configuration? To know more about the default configuration see: https://webhint.io/docs/user-guide/#default-configuration`;
    const confirmation = await askQuestion(question);
    if (confirmation) {
        return getDefaultConfiguration(targets);
    }
    return null;
};
const showMissingAndIncompatiblePackages = (resources) => {
    if (resources.missing.length > 0) {
        utils_1.logger.log(`The following ${resources.missing.length === 1 ? 'package is' : 'packages are'} missing:
    ${resources.missing.join(', ')}`);
    }
    if (resources.incompatible.length > 0) {
        utils_1.logger.log(`The following ${resources.incompatible.length === 1 ? 'package is' : 'packages are'} incompatible:
    ${resources.incompatible.join(', ')}`);
    }
};
const askUserToInstallDependencies = async (resources) => {
    showMissingAndIncompatiblePackages(resources);
    const dependencies = resources.incompatible.concat(resources.missing);
    const question = `There ${dependencies.length === 1 ? 'is a package' : 'are packages'} from your .hintrc file not installed or with an incompatible version. Do you want us to try to install/update them?`;
    const answer = await askQuestion(question);
    return answer;
};
const getLanguage = async (userConfig, actions) => {
    if (actions && actions.language) {
        debug(`Using language option provided from command line: ${actions.language}`);
        return actions.language;
    }
    if (userConfig && userConfig.language) {
        debug(`Using language option provided in user config file: ${userConfig.language}`);
        return userConfig.language;
    }
    const osLanguage = await osLocale();
    debug(`Using language option configured in the OS: ${osLanguage}`);
    return osLanguage;
};
const loadUserConfig = async (actions, targets) => {
    let userConfig = __1.getUserConfig(actions.config);
    if (!userConfig) {
        userConfig = getDefaultConfiguration(targets);
    }
    userConfig.language = await getLanguage(userConfig, actions);
    userConfig = mergeEnvWithOptions(userConfig);
    return userConfig;
};
const askToInstallPackages = async (resources) => {
    if (resources.missing.length > 0) {
        utils_1.appInsights.trackEvent('cli-missing', resources.missing);
    }
    if (resources.incompatible.length > 0) {
        utils_1.appInsights.trackEvent('cli-incompatible', resources.incompatible);
    }
    const missingPackages = resources.missing.map((name) => {
        return `@hint/${name}`;
    });
    const incompatiblePackages = resources.incompatible.map((name) => {
        return `@hint/${name}@latest`;
    });
    if (!(await askUserToInstallDependencies(resources) &&
        await installPackages(missingPackages) &&
        await installPackages(incompatiblePackages))) {
        return false;
    }
    return true;
};
const getAnalyzer = async (userConfig, options, targets) => {
    let webhint;
    try {
        webhint = __1.createAnalyzer(userConfig, options);
    }
    catch (e) {
        const error = e;
        if (error.status === error_status_1.AnalyzerErrorStatus.ConfigurationError) {
            const config = await askUserToUseDefaultConfiguration(targets);
            if (!config) {
                throw e;
            }
            return getAnalyzer(config, options, targets);
        }
        if (error.status === error_status_1.AnalyzerErrorStatus.ResourceError) {
            const installed = await askToInstallPackages(error.resources);
            if (!installed) {
                throw e;
            }
            return getAnalyzer(userConfig, options, targets);
        }
        if (error.status === error_status_1.AnalyzerErrorStatus.HintError) {
            utils_1.logger.error(`Invalid hint configuration in .hintrc: ${error.invalidHints.join(', ')}.`);
            throw e;
        }
        if (error.status === error_status_1.AnalyzerErrorStatus.ConnectorError) {
            utils_1.logger.error(`Invalid connector configuration in .hintrc`);
            throw e;
        }
        utils_1.logger.error(e.message, e);
        throw e;
    }
    return webhint;
};
const actionsToOptions = (actions) => {
    const options = {
        formatters: actions.formatters ? actions.formatters.split(',') : undefined,
        hints: actions.hints ? actions.hints.split(',') : undefined,
        watch: actions.watch
    };
    return options;
};
exports.default = async (actions) => {
    const targets = getAsUris(actions._);
    if (targets.length === 0) {
        return false;
    }
    const userConfig = await loadUserConfig(actions, targets);
    const createAnalyzerOptions = actionsToOptions(actions);
    let webhint;
    try {
        webhint = await getAnalyzer(userConfig, createAnalyzerOptions, targets);
    }
    catch (e) {
        return false;
    }
    const start = Date.now();
    let exitCode = 0;
    const endSpinner = (method) => {
        if (!actions.debug && spinner[method]) {
            spinner[method]();
        }
    };
    const hasError = (reports) => {
        return reports.some((result) => {
            return result.severity === problems_1.Severity.error;
        });
    };
    const print = async (reports, target, scanTime, date) => {
        await webhint.format(reports, {
            config: userConfig || undefined,
            date,
            output: actions.output ? path.resolve(cwd(), actions.output) : undefined,
            resources: webhint.resources,
            scanTime,
            target,
            version: load_hint_package_1.loadHintPackage().version
        });
    };
    const getAnalyzeOptions = () => {
        const scanStart = new Map();
        const analyzerOptions = {
            targetEndCallback: undefined,
            targetStartCallback: undefined,
            updateCallback: undefined
        };
        if (!actions.debug) {
            analyzerOptions.updateCallback = (update) => {
                spinner.text = update.message;
            };
        }
        analyzerOptions.targetStartCallback = (start) => {
            if (!actions.debug) {
                spinner.start();
            }
            scanStart.set(start.url, Date.now());
        };
        analyzerOptions.targetEndCallback = async (end) => {
            const scanEnd = Date.now();
            const start = scanStart.get(end.url) || 0;
            if (hasError(end.problems)) {
                exitCode = 1;
            }
            endSpinner(exitCode ? 'fail' : 'succeed');
            await print(end.problems, end.url, scanEnd - start, new Date(start).toISOString());
        };
        return analyzerOptions;
    };
    try {
        await webhint.analyze(targets, getAnalyzeOptions());
        await sendTelemetryIfEnabled(userConfig);
    }
    catch (e) {
        exitCode = 1;
        endSpinner('fail');
        debug(`Failed to analyze: ${e.url}`);
        debug(e);
    }
    debug(`Total runtime: ${Date.now() - start}ms`);
    return exitCode === 0;
};
