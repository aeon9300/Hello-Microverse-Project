/// <reference types="node" />
import * as url from 'url';
import { EventEmitter2 as EventEmitter } from 'eventemitter2';
import { HttpHeaders } from '@hint/utils/dist/src/types/http-header';
import { HTMLElement, HTMLDocument } from '@hint/utils/dist/src/dom/html';
import { Events, HintResources, IFetchOptions, IFormatter, NetworkData, StringKeyOf } from './types';
import { Configuration } from './config';
import { Problem } from '@hint/utils/dist/src/types/problems';
export declare class Engine<E extends Events = Events> extends EventEmitter {
    private parsers;
    private hints;
    private connector;
    private messages;
    private browserslist;
    private ignoredUrls;
    private _formatters;
    private _timeout;
    private _lang;
    readonly pageDOM: HTMLDocument | undefined;
    readonly pageContent: string | undefined;
    readonly pageHeaders: HttpHeaders | undefined;
    readonly targetedBrowsers: string[];
    readonly formatters: IFormatter[];
    readonly timeout: number;
    private isIgnored;
    constructor(config: Configuration, resources: HintResources);
    onHintEvent<K extends StringKeyOf<E>>(id: string, eventName: K, listener: (data: E[K], event: string) => void): void;
    fetchContent(target: string | url.URL, headers?: object): Promise<NetworkData>;
    evaluate(source: string): Promise<any>;
    close(): Promise<void>;
    report(problem: Problem): void;
    clean(fileUrl: url.URL): void;
    clear(): void;
    notify(this: Engine<Events>, resource: string): Promise<void>;
    executeOn(target: url.URL, options?: IFetchOptions): Promise<Problem[]>;
    querySelectorAll(selector: string): HTMLElement[];
    emit<K extends StringKeyOf<E>>(event: K, data: E[K]): boolean;
    emitAsync<K extends StringKeyOf<E>>(event: K, data: E[K]): Promise<any[]>;
    on<K extends StringKeyOf<E>>(event: K, listener: (data: E[K]) => void): this;
    readonly language: string;
}
//# sourceMappingURL=engine.d.ts.map