"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const path = require("path");
const merge = require("lodash/merge");
const load_json_file_1 = require("@hint/utils/dist/src/fs/load-json-file");
const as_path_string_1 = require("@hint/utils/dist/src/network/as-path-string");
const as_uri_1 = require("@hint/utils/dist/src/network/as-uri");
class Parser {
    constructor(engine, parseEventType) {
        this.engine = engine;
        this.name = parseEventType;
    }
    finalConfig(config, resource) {
        if (!config.extends) {
            return config;
        }
        const configIncludes = [];
        let configPath = as_path_string_1.asPathString(as_uri_1.getAsUri(resource));
        configIncludes.push(path.normalize(configPath));
        let finalConfigJSON = merge({}, config);
        while (finalConfigJSON.extends) {
            const lastPath = configPath;
            const configDir = path.dirname(configPath);
            configPath = path.resolve(configDir, finalConfigJSON.extends);
            if (configIncludes.includes(configPath)) {
                const error = new Error(`Circular reference found in file ${lastPath}`);
                const originalPathUri = as_uri_1.getAsUri(configIncludes[0]);
                error.resource = originalPathUri && originalPathUri.toString() || lastPath;
                return error;
            }
            delete finalConfigJSON.extends;
            try {
                const extendedConfig = load_json_file_1.loadJSONFile(configPath);
                configIncludes.push(configPath);
                finalConfigJSON = merge({}, extendedConfig, finalConfigJSON);
            }
            catch (err) {
                const lastPathUri = as_uri_1.getAsUri(lastPath);
                err.resource = lastPathUri && lastPathUri.toString() || lastPath;
                return err;
            }
        }
        return finalConfigJSON;
    }
}
exports.Parser = Parser;
